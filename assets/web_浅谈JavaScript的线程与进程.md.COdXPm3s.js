import{_ as s,o as i,c as a,a7 as n}from"./chunks/framework.ClMj9r9D.js";const t="/images/2020/09/task.jpg",y=JSON.parse('{"title":"浅谈JavaScript的线程与进程","description":"","frontmatter":{"title":"浅谈JavaScript的线程与进程","tags":["javascript","ES6"],"categories":["Web"],"abbrlink":"5bd537b","date":"2020-09-14T10:34:10.000Z"},"headers":[],"relativePath":"web/浅谈JavaScript的线程与进程.md","filePath":"web/浅谈JavaScript的线程与进程.md","lastUpdated":1720625041000}'),p={name:"web/浅谈JavaScript的线程与进程.md"},e=n('<p>首先，JavaScript 是单线程语言。</p><h3 id="_1-进程和线程的关系" tabindex="-1">1. 进程和线程的关系 <a class="header-anchor" href="#_1-进程和线程的关系" aria-label="Permalink to &quot;1. 进程和线程的关系&quot;">​</a></h3><p>一个程序至少有一个进程，而一个进程至少有一个线程。线程是进程的执行单元，是 CPU 调度和分派的基本单位，可以看成实际在干活运算的是线程，而进程只是一个或多个线程的资源分配和调度的系统单位。</p><p>如果把进程比作一个工厂，线程则是工厂里干活的工人。工人共享一个劳动空间，共享劳动工具。也就是说，在一个进程里，有一个或多个线程，各线程共享同一个内存空间和数据。</p><p>可以看看阮一峰的<a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noreferrer">《进程与线程的一个简单解释》</a>。</p><h3 id="_2-浏览器是多线程" tabindex="-1">2. 浏览器是多线程 <a class="header-anchor" href="#_2-浏览器是多线程" aria-label="Permalink to &quot;2. 浏览器是多线程&quot;">​</a></h3><ul><li>GUI 渲染线程</li><li>JS 引擎线程</li><li>事件触发线程</li><li>定时触发线程</li><li>异步 HTTP 请求线程</li></ul><p>其中，GUI 线程和 JS 线程是互斥的。这也就是为什么某些页面在执行 JS 运算时会导致 DOM 刷新卡住。因为当 JS 线程在执行运算时，GUI 线程会被挂起。</p><p>早期通过在代码中增加 <code>setTimeout</code> 来解决渲染卡顿问题。</p><h3 id="_3-javascript-是单线程" tabindex="-1">3. JavaScript 是单线程 <a class="header-anchor" href="#_3-javascript-是单线程" aria-label="Permalink to &quot;3. JavaScript 是单线程&quot;">​</a></h3><p>JavaScript 可以同时执行多个 JS 文件代码，看似多线程同时执行，其实还是单线程，只不过是分隔成多个任务，在不同任务之间跳转进行运算。</p><p>JavaScript 的执行机制称为 Event Loop。任务分为同步和异步。</p><p>同步任务都在主线程上执行，遇到异步任务则丢到任务队列，接着继续执行同步任务。当同步任务执行完毕，主线程空闲后，才会回过头去查看任务队列。</p><p><img src="'+t+`" alt="event loop"> （图片来源于谷歌，描述了任务在事件循环中的执行顺序）</p><p>这也就是 <code>setTimeout(() =&gt; {}, 0)</code> 并不会立马执行，延迟时间并不准确的原因，因为主线程还没空闲去执行任务队列。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;哟哟哟&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>执行时，并不是说放到任务队列，1000ms 后执行，而是由定时器线程在 1000ms 后才丢到队列！常用的 setInterval 也是一样的逻辑。</p><h3 id="_4-宏任务与微任务" tabindex="-1">4. 宏任务与微任务 <a class="header-anchor" href="#_4-宏任务与微任务" aria-label="Permalink to &quot;4. 宏任务与微任务&quot;">​</a></h3><p><strong>宏任务 (macrotask)</strong>，包括主线程、setTimeout、setInterval、requestAnimationFrame。</p><p><strong>微任务 (microtask)</strong>，包括 Promise、process.nextTick、MutationObserver 以及已废弃的 Object.observe。</p><p>前面提到通过在代码中增加 setTimeout 来解决渲染卡顿问题，因为 JS 线程和 GUI 线程互斥，所以执行的顺序实际上是这样：</p><p>JS 任务 =&gt; 渲染 DOM =&gt; JS 任务 =&gt; 渲染 DOM</p><p>通过 setTimeout 把长运算代码切片处理，防止 JS 执行时间太长造成页面假死。</p><p>微任务则是在渲染之前执行。简单来说，在主代码执行完后，执行渲染，然后再去查看任务队列。</p><p>但是如果有微任务，则是执行主代码后，先执行微任务，然后渲染，再执行任务队列。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;begin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise.resolve&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>执行结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>begin</span></span>
<span class="line"><span>promise</span></span>
<span class="line"><span>end</span></span>
<span class="line"><span>promise.resolve</span></span>
<span class="line"><span>setTimeout</span></span></code></pre></div><p>可以看出 <code>Promise.resolve</code> 是在 <code>setTimeout</code> 之前执行的。网上有很多示例代码，套了很多层，实际工作中并不常用到。</p>`,29),l=[e];function h(k,r,E,o,d,c){return i(),a("div",{"data-pagefind-body":!0},l)}const F=s(p,[["render",h]]);export{y as __pageData,F as default};
