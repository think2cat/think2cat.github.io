import{_ as a,o,c as e,a7 as t}from"./chunks/framework.Z1Dznsxj.js";const u=JSON.parse('{"title":"从图书馆借书到MongoDB锁：一文看懂锁机制","description":"","frontmatter":{"sticky":1,"title":"从图书馆借书到MongoDB锁：一文看懂锁机制","abbrlink":"c6a8bf4d","date":"2024-06-16T11:46:37.000Z","tags":["MongoDB","DB","数据库锁"],"categories":["IT"]},"headers":[],"relativePath":"IT/从图书馆借书到MongoDB锁.md","filePath":"IT/从图书馆借书到MongoDB锁.md","lastUpdated":1719711816000}'),r={name:"IT/从图书馆借书到MongoDB锁.md"},i=t('<h2 id="什么是锁" tabindex="-1">什么是锁 <a class="header-anchor" href="#什么是锁" aria-label="Permalink to &quot;什么是锁&quot;">​</a></h2><p>锁是一种机制，用于管理并发访问和维护数据一致性。它确保多个操作不会同时修改相同的数据，从而避免数据冲突。</p><p>假设图书馆里有一批热门书籍，很多人都想借阅。图书馆为了管理这些书籍的借阅过程，引入了不同类型的“锁”。</p><h2 id="锁的种类" tabindex="-1">锁的种类 <a class="header-anchor" href="#锁的种类" aria-label="Permalink to &quot;锁的种类&quot;">​</a></h2><h3 id="_1-共享锁-s锁" tabindex="-1">1. 共享锁（S锁） <a class="header-anchor" href="#_1-共享锁-s锁" aria-label="Permalink to &quot;1. 共享锁（S锁）&quot;">​</a></h3><p>共享锁允许多个事务并发读取同一数据，但不能进行写操作。读读不互斥，多个事务可以同时获取共享锁。</p><p><code>图书馆允许多个人同时阅读同一本书，但不能带走。也就是说，书架上的书可以被很多人同时拿下来翻阅，但不能被借走。</code></p><h3 id="_2-排他锁-x锁" tabindex="-1">2.排他锁（X锁） <a class="header-anchor" href="#_2-排他锁-x锁" aria-label="Permalink to &quot;2.排他锁（X锁）&quot;">​</a></h3><p>排他锁允许一个事务进行写操作，同时阻止其他事务读取或写入。写写互斥，读写互斥，只有一个事务能持有排他锁。</p><p><code>图书馆规定，当一个人借书时，其他人不能同时借这本书，也不能翻阅这本书。借书的人会把书从书架上拿走，直到他归还后，其他人才可以继续借阅或查看这本书。</code></p><h3 id="_3-意向共享锁-is锁" tabindex="-1">3.意向共享锁（IS锁） <a class="header-anchor" href="#_3-意向共享锁-is锁" aria-label="Permalink to &quot;3.意向共享锁（IS锁）&quot;">​</a></h3><p>意向共享锁表示一个事务有读取某些资源的意图。多个事务可以同时获取意向共享锁和意向排他锁。</p><p><code>图书馆规定，一个人如果计划去翻阅某本书，他可以提前在图书馆的系统里登记自己的意图，这样系统知道将来可能会有很多人同时查看这本书。登记意图的人还没有拿到书，但图书馆知道他有这个计划。</code></p><h3 id="_4-意向排他锁-ix锁" tabindex="-1">4.意向排他锁（IX锁） <a class="header-anchor" href="#_4-意向排他锁-ix锁" aria-label="Permalink to &quot;4.意向排他锁（IX锁）&quot;">​</a></h3><p>意向排他锁表示一个事务有写入某些资源的意图。多个事务可以同时获取意向排他锁，但不能获取共享锁或排他锁。</p><p><code>图书馆规定，一个人如果计划去借某本书，他可以提前在图书馆的系统里登记自己的意图，这样系统知道将来可能会有很多人要借这本书。登记意图的人还没有拿到书，但图书馆知道他有这个计划。</code></p><h3 id="图书馆场景" tabindex="-1">图书馆场景 <a class="header-anchor" href="#图书馆场景" aria-label="Permalink to &quot;图书馆场景&quot;">​</a></h3><p>假设图书馆里有一本《哈利波特与数据结构》的书，多个读者对这本书感兴趣。</p><p><strong>共享锁（S锁）：</strong> 多个读者可以同时在图书馆翻阅《哈利波特与数据结构》，但不能借走。</p><p><strong>排他锁（X锁）：</strong> 一个读者决定借走《哈利波特与数据结构》，在他借走期间，其他读者不能翻阅或借走这本书。</p><p><strong>意向共享锁（IS锁）：</strong> 多个读者计划将来翻阅《哈利波特与数据结构》，他们在图书馆系统里登记了这个意图。图书馆知道这些读者有查看的意图，但他们还没有真正拿到书。</p><p><strong>意向排他锁（IX锁）：</strong> 几个读者计划将来借走《哈利波特与数据结构》，他们在图书馆系统里登记了这个意图。图书馆知道这些读者有借走的意图，但他们还没有真正拿到书。</p><p>通过这些例子，可以看到不同类型的锁在管理并发访问时的作用。共享锁和排他锁直接控制实际的读写操作，而意向共享锁和意向排他锁则用来表示未来的操作意图，从而更好地协调和管理资源。</p><h2 id="锁的粒度" tabindex="-1">锁的粒度 <a class="header-anchor" href="#锁的粒度" aria-label="Permalink to &quot;锁的粒度&quot;">​</a></h2><p>MongoDB的锁机制有不同的粒度，主要包括以下几种：</p><ul><li>数据库级锁：锁定整个数据库，通常用于数据库级别的操作。</li><li>集合级锁：锁定单个集合，适用于集合级别的操作。</li><li>文档级锁：锁定单个文档，MongoDB 3.0及以后版本引入的细粒度锁，可以提高并发性能。</li><li>存储引擎锁：针对不同存储引擎（如WiredTiger）的内部锁机制，影响底层数据存储和访问</li></ul><h3 id="图书馆场景-1" tabindex="-1">图书馆场景 <a class="header-anchor" href="#图书馆场景-1" aria-label="Permalink to &quot;图书馆场景&quot;">​</a></h3><p>回到图书馆例子，以上的锁分别对应</p><ul><li><strong>图书馆级锁</strong> 这是最粗粒度的锁，相当于图书馆未到开放时间，任何人无法查找或借阅书籍</li><li><strong>书架级锁</strong> 一般同个级别的书会放到一个书架，当需要整理某个书架时，该书架上所有书都无法查看或借阅，其它书架则可正常查看和借阅</li><li><strong>书本级锁</strong> 当我正在查看《哈利波特与数据结构》时，其他人不可查看，但是不影响查看和借阅其它书籍</li><li><strong>后勤锁</strong> 图书馆停电了，不直接影响查看和借阅，只是因为没灯没空调，会影响用户体验</li></ul><h2 id="结尾" tabindex="-1">结尾 <a class="header-anchor" href="#结尾" aria-label="Permalink to &quot;结尾&quot;">​</a></h2><p>通过上述内容，我们可以清晰地了解MongoDB中不同类型的锁及其粒度如何影响并发访问和性能。锁是数据库管理系统中至关重要的机制，它确保数据的一致性和完整性，同时在高并发环境下维持系统的稳定性。对于开发者来说，理解和合理使用这些锁，可以有效地优化数据库的性能，并在并发环境下保持数据的正确性和一致性。希望这篇文章能帮助你更好地理解和应用MongoDB的锁机制。</p>',31),n=[i];function l(s,d,h,p,c,_){return o(),e("div",{"data-pagefind-body":!0},n)}const b=a(r,[["render",l]]);export{u as __pageData,b as default};
