import{_ as s,o as a,c as i,a7 as e}from"./chunks/framework.Z1Dznsxj.js";const E=JSON.parse('{"title":"《SQL Server 2000存储过程与XML编程》学习笔记","description":"","frontmatter":{"title":"《SQL Server 2000存储过程与XML编程》学习笔记","tags":["sql","xml","笔记"],"id":1019,"categories":["IT"],"abbrlink":"e5b237f1","date":"2008-04-16T10:04:40.000Z"},"headers":[],"relativePath":"IT/SQLServer2000存储过程与XML编程_学习笔记.md","filePath":"IT/SQLServer2000存储过程与XML编程_学习笔记.md","lastUpdated":1720625041000}'),t={name:"IT/SQLServer2000存储过程与XML编程_学习笔记.md"},l=e(`<p><img src="http://otho.douban.com/mpic/s2226371.jpg" alt=""><a href="http://www.douban.com/subject/1144051/" target="_blank" rel="noreferrer">豆瓣链接</a></p><p>SQL Server 2000存储过程与XML编程（第2版） 又名: SQL Server 2000 Stored Procedure &amp; XML Programming,Second Editon</p><pre><code>译者: 石朝江 / 谢俊 / 陈浩奎
作者: [美]桑德里克
ISBN: 9787302077343
</code></pre><p>去年的时候拿着同事的借书证有幸一读，无奈没多久同事就去了外地，匆匆还了书取消了借书证，还没读完，有点遗憾，只留下几句笔记</p><p>创建于：2007年6月13日星期三 最后更新：2007年7月8日星期日</p><h2 id="一、-什么是存储过程" tabindex="-1">一、 什么是存储过程 <a class="header-anchor" href="#一、-什么是存储过程" aria-label="Permalink to &quot;一、 什么是存储过程&quot;">​</a></h2><p>一个T-SQL语法集，被编译并存储为一个单一的数据库对象，供以后重复使用</p><h3 id="_1-组成" tabindex="-1">1. 组成 <a class="header-anchor" href="#_1-组成" aria-label="Permalink to &quot;1. 组成&quot;">​</a></h3><ul><li>头部，定义名称、输入参数和输出参数，以及其它处理选项</li><li>主体，包含一个或多个T-SQL语句</li><li>例子：<div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Create</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Procedure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prGetBookList</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @booktype </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> From</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> book</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Where</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @booktype</span></span></code></pre></div></li></ul><h3 id="_2-命名规范" tabindex="-1">2. 命名规范 <a class="header-anchor" href="#_2-命名规范" aria-label="Permalink to &quot;2. 命名规范&quot;">​</a></h3><p>通常用pr开通表示存储过程，再结合动词和名次，用于描述该存储过程，例如 proGetBookList</p><h3 id="_3-限制" tabindex="-1">3. 限制 <a class="header-anchor" href="#_3-限制" aria-label="Permalink to &quot;3. 限制&quot;">​</a></h3><ol><li>过程名称最大长度128个字符</li><li>最多可以包含2100个输入参数和输出参数</li><li>主体最大不超过128MB</li></ol><h3 id="_4-功能" tabindex="-1">4. 功能 <a class="header-anchor" href="#_4-功能" aria-label="Permalink to &quot;4. 功能&quot;">​</a></h3><ol><li>返回信息给调用者</li><li>修改数据库中的数据</li><li>在数据层实现业务逻辑</li><li>控制数据访问权限</li><li>改善系统性能</li><li>降低网络流量</li><li>执行其它动作和操作（比如处理电子邮件、执行各类操作系统命令和进程、管理其它的SQL Server对象）</li></ol><h3 id="_5-执行" tabindex="-1">5. 执行 <a class="header-anchor" href="#_5-执行" aria-label="Permalink to &quot;5. 执行&quot;">​</a></h3><p>运行任何T-SQL语句时，SQL Server都要执行以下3步</p><ol><li>解析批处理</li><li>编译批处理</li><li>执行批处理</li></ol><p>与查询相比，存储过程效率更好的原因就是执行计划可以重用，因为如果执行3次查询，那么SQL Server就要3次对它进行解析、重新编译并执行，而存储过程只需重新编译一次。</p><p>执行存储过程语句为： <code>Ececute prGetBooklist 2</code></p><p>如果存储过程在批处理第一条语句执行，关键字<code>Execute</code>可以省略，但建议使用该关键字，如以下2句是一样的</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prGetBooklist </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Ecec prGetBooklist </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span></code></pre></div><h2 id="二、-t-sql基本编程结构" tabindex="-1">二、 T-SQL基本编程结构 <a class="header-anchor" href="#二、-t-sql基本编程结构" aria-label="Permalink to &quot;二、 T-SQL基本编程结构&quot;">​</a></h2><h3 id="_1-变量" tabindex="-1">1. 变量 <a class="header-anchor" href="#_1-变量" aria-label="Permalink to &quot;1. 变量&quot;">​</a></h3><p><strong>局部变量</strong></p><p>作用域位于批处理中，一个存储过程不能访问其它存储过程中定义的变量</p><p><strong>声明</strong></p><p>变量以@开头，例如 <code>Declare @LastName varchar(50)</code> Declare语句可以一次声明多个变量，中间用逗号分开，例如 <code>Declare @LastName varchar(50), @FirstName varchar(50), @BirthDate smalldatetime</code></p><p><strong>赋值</strong></p><p>早期SQL Server唯一赋值方法就是select，一个select语句可以同时给多个变量赋值，例如</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @LastName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ‘Kuo’, @FirstName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">’Gavin’, @BirthDate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">’</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2007</span></span></code></pre></div><p>早期只可以使用Set语句声明游标变量，现在微软推荐使用set语句来声明变量，例如</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @LastName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ‘Kuo’</span></span></code></pre></div><p>但是Set语句一次只能声明一个变量</p><p><strong>全局变量</strong></p><p>可以从任何位置（存储过程或批处理中）对它们进行分析。 全局变量名称以 <code>@@</code> 开头，它们属于系统定义的函数，不能对它们进行声明。</p><p>最重要的几个全局变量</p><ul><li><code>@@identity</code> 每个表都有一个可以定义为Identity列的列，值为编号，并且在表里面是唯一的。 该变量允许你获取当前对话中生成的最后一个标示值。例如在insert一条或若干条记录之后可以用 select <code>@@identity</code>获取最后一条记录的标示值</li><li><code>@@error</code> 返回整型值，每执行一个SQL语句后系统都会重置该值 0表示执行成功</li><li><code>@@rowcount</code> 每执行一个SQL语句后系统将该值设置为语句所影响的总记录数，可以用来确认操作的成功与否</li></ul><h3 id="_2-流控制语法" tabindex="-1">2. 流控制语法 <a class="header-anchor" href="#_2-流控制语法" aria-label="Permalink to &quot;2. 流控制语法&quot;">​</a></h3><p><strong>注释</strong></p><p>单行注释 <code>--</code> 多行注释 <code>/……/</code> 多行注释不可相互嵌套，但可以嵌套单行注释 多行注释里面，一般开头使用 <code>**</code> 表示，表示该行为注释，便于阅读</p><p><strong>语句块Begin…end</strong></p><p>主要对逻辑单元进行分组，可以嵌套使用，但最好是使用缩进避免出错。</p><p><strong>If…else</strong></p><p>根据条件值确定代码流向，else为可选，if语句可以相互嵌套 注意，if语句并没有end if结尾</p><p><strong>While…break</strong></p><p>T-SQL唯一一个循环语句，中间可以使用break中断循环，或continue跳过下面语句重新循环，一般跟begin…end配套使用</p><p><strong>Goto</strong></p><p>强制跳到某一label，例如</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Goto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> label2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Label2:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span></code></pre></div><p><strong>Waitfor</strong></p><p>延时，参数有两种变量 <code>Waitfor delay &#39;00:01:00&#39;</code> 表示等待1分钟后再执行下面语句，时间参数必须小于24小时 <code>Waitfor time &#39;17:55&#39;</code> 表示直到17:55才执行下面语句</p><h3 id="_3-游标" tabindex="-1">3. 游标 <a class="header-anchor" href="#_3-游标" aria-label="Permalink to &quot;3. 游标&quot;">​</a></h3>`,53),n=[l];function p(h,r,o,d,k,c){return a(),i("div",{"data-pagefind-body":!0},n)}const u=s(t,[["render",p]]);export{E as __pageData,u as default};
